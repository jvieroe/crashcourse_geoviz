---
title: 'Crash course: Geospatial Datavisualisering'
author: "Jeppe Vierø"
date: \today
output:
  beamer_presentation:
    theme: "CambridgeUS"
    colortheme: "default"
    toc: yes
    slide_level: 2
    keep_tex: yes
    highlight: pygments
    includes:
      in_header: header.tex
classoption: "aspectratio=169"
fontsize: 8pt
urlcolor: blue
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  paste0("\n \\", "tiny","\n\n", x, "\n\n \\normalsize")
})

```

# xx



# Introduktion

## Motivation

\begin{figure}[H]
	\centering
	\includegraphics[width=.90\textwidth]{pictures/Minard.png}
	\caption{by Charles Joseph Minard, 1869}
\end{figure}


## Afgrænsning

Jeg (regner med) at snakke __en del__ om:

* Hvad __spatial__ data er

* Hvordan vi kan bruge spatiale datakilder til at __visualisere__ andet data

* Hvordan vi gør det i `R`


\bigskip

Jeg kommer __ikke__ til at snakke (så meget) om:

* Datawrangling og -manipulation med geospatial data

* Datavisualisering generelt



## Hvordan kan vi bruge geodata til at visualisere vores pointer?

\columnsbegin

\column{.5\textwidth}

\begin{figure}[H]
	\centering
	\includegraphics[width=.90\textwidth]{pictures/fuel.png}
\end{figure}


\column{.5\textwidth}

\onslide <2->
\begin{figure}[H]
	\centering
	\includegraphics[width=.90\textwidth]{pictures/Forstadsbilister_start.png}
\end{figure}


\columnsend




## Hvordan kan vi bruge geodata til at visualisere vores pointer?

\columnsbegin

\column{.4\textwidth}

\begin{figure}[H]
	\centering
	\includegraphics[width=.70\textwidth]{pictures/potentialeudnyttelse_absolut.png}
\end{figure}


\column{.6\textwidth}

\onslide <2->
\begin{figure}[H]
	\centering
	\includegraphics[width=.99\textwidth]{pictures/hex_ringsted.png}
\end{figure}


\columnsend



## Hvorfor ikke bare bruge klassiske visualiseringer?



<!-- ## R Markdown -->

<!-- This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>. -->

<!-- When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: -->

<!-- ```{r cars} -->
<!-- summary(cars) -->
<!-- ``` -->

<!-- ## Including Plots -->

<!-- You can also embed plots, for example: -->

<!-- ```{r pressure} -->
<!-- plot(pressure) -->
<!-- ``` -->

<!-- Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot. -->





# Datastrukturer


## Need to know om geodata

text

## Typer af geodata

Grundlæggende arbejder vi med __tre typer af geospatiale datakilder__

Hver type har en (nogenlunde) parallel til graftyper, I er vant til at arbejde med:

\bigskip

1. __Punkter__
  + Tænk på dem som almindelige _punkter i et scatterplot_


2. __Linjer__
  + Tænk på dem som _linjer i et linechart_


3. __Polygoner__
  + Her er parallelen ikke lige så tydelig
  + ... men i en data viz-kontekst kan I tænke på dem som _søjler i et bar chart_ (ish...)




## load

```{r, warning=FALSE,message=FALSE}
library(tidyverse)
library(janitor)
library(sf)
library(tmap)
library(repinion)

# Installér {repinion}, hvis I ikke har den:
# devtools::install_github("jvieroe/repinion")

```
## xxxx

xxx







```{r, echo=F, eval=TRUE, message=FALSE,warning=FALSE, results='hide'}
regioner <- st_read(dsn = "data/regioner",
                    layer = "regioner")

kommuner <- st_read(dsn = "data/kommuner",
                    layer = "kommuner")

metrostop <- st_read(dsn = "data/metro_stops",
                    layer = "metro_stops")

metrolinjer <- st_read(dsn = "data/metro_lines",
                       layer = "metro_lines")

dsb <- readxl::read_xlsx("data/DSB_Stations_20201209.xlsm") %>% 
  clean_names() %>% 
  filter(!is.na(x) & !is.na(y)) %>% 
  st_as_sf(coords = c("x", "y"),
           crs = 4326) %>% 
  st_intersection(.,
                  regioner)

rejser <- readRDS("data/rejsekortdata.rds")


```

## (1) Punkter

\columnsbegin
\column{.4\textwidth}


* Punkter består af simple koordinater (x, y), der refererer til en specifik lokation

* Punkter har ingen størrelse (og intet _areal_), de er uendeligt små

* Eksempler: byer, stationer, skoler osv.

\column{.6\textwidth}

```{r, echo=F, eval=TRUE, out.width='100%'}
ggplot() +
  geom_sf(data = dsb, alpha = .5) +
  epitheme_map()

```


\columnsend


## (2) Linjer

\columnsbegin
\column{.4\textwidth}


* Linjer består -- grundlæggende -- af punkter, der er kombineret til en _linestring_ vha. en defineret rækkefølge

* Konstruktionen er sjældent noget, I skal bekymre jer om: linjedata ligger typisk opbevaret som linjer ($\neq$ punkter). Her er det bare plug 'n play

* Linjer har intet _areal_ (fordi de består af punkter)

* Eksempler: veje, floder, jernbanenetværk osv.


\column{.6\textwidth}

```{r, echo=F, eval=TRUE, out.width='100%'}
ggplot() +
  geom_sf(data = metrolinjer) +
  epitheme_map()

```


\columnsend


## (3) Polygoner

\columnsbegin
\column{.4\textwidth}

* Polygoner består -- ligesom linjer -- af punkter, der er kombineret til en _polygon_ vha. en defineret rækkefølge. Igen, det er sjældent noget, I skal bekymre jer om

* Forskellen er, at polygoner er _lukkede linjer_, der former et afgrænset område

* De kan have alle tænkelige former. Det centrale er, at polygoner har et _areal_

* Eksempler: stater, kommuner, valgkredse osv.


\column{.6\textwidth}

```{r, echo=F, eval=TRUE, out.width='100%'}
ggplot() +
  geom_sf(data = regioner) +
  epitheme_map()

```


\columnsend



# Datakilder

## DAGI

\columnsbegin

\column{.6\textwidth}

* _"__Danmarks Administrative Geografiske Inddeling (DAGI)__ beskriver landets administrative og geografiske inddeling i kommuner, regioner, sogne, retskredse, politikredse, postnumre, opstillingskredse og lignende."_ -- [DAWA](https://dawadocs.dataforsyningen.dk/dok/dagi)

\medskip

* ... med andre ord; alt hvad vi kunne drømme om

* DAGI-data kan hentes via Styrelsen for Dataforsyning og Effektiviserings [Datafordeler](https://datafordeler.dk/dataoversigt/)

* Det er en ret håbløs hjemmeside, til gengæld er der masser at vælge mellem (inkl. historiske enheder!)



\column{.4\textwidth}



\begin{figure}[H]
	\centering
	\includegraphics[width=.90\textwidth]{pictures/logo_sdfe.png}
\end{figure}


\columnsend


## DAGI


* Til de fleste formål kan vi hoppe uden om Datafordelen ved at bruge [DAWA (Danmarks Adressers Web API)](https://dawadocs.dataforsyningen.dk/dok/dagi) og den [tilhørende API](https://dawadocs.dataforsyningen.dk/dok/api#dagi) 

* API'en er plug 'n play, hvor vi kan vælge de \textcolor{purple}{enheder}, vi skal bruge, og specificere \textcolor{teal}{format}:

* \nolinkurl{https://api.dataforsyningen.dk/ \textcolor{purple}{kommuner}?format=\textcolor{teal}{geojson}}



## DAGI: et eksempel

\columnsbegin
\column{.5\textwidth}

```{r, eval=F}
# definér data
url <- 
  "https://api.dataforsyningen.dk/kommuner?format=geojson"

# indlæs data
kommuner_raw <- 
  read_sf(url)

# plot data
ggplot() +
  geom_sf(data = kommuner_raw) +
  epitheme_map()

```
\column{.5\textwidth}
```{r, echo=F}
# definér data
url <- 
  "https://api.dataforsyningen.dk/kommuner?format=geojson"

# indlæs data
kommuner_raw <- 
  read_sf(url)

# plot data
ggplot() +
  geom_sf(data = kommuner_raw) +
  epitheme_map()

```
\columnsend








## OpenStreetMap


\columnsbegin

\column{.6\textwidth}

* [OpenStreetMap (OSM)](https://www.openstreetmap.org/about) er en crowd sourced geografisk database med detaljeret information om hele verden

* OSM indeholder data på (næsten) alt, hvad hjertet begærer 

\bigskip

* OSM har en tilhørende [wiki](https://wiki.openstreetmap.org/wiki/Map_features), med en oversigt over de forskellige features

\column{.4\textwidth}


\begin{figure}[H]
	\centering
	\includegraphics[width=.75\textwidth]{pictures/Openstreetmap_logo.svg}
\end{figure}


\columnsend


## OpenStreetMap


\columnsbegin

\column{.6\textwidth}

* Vi kan bruge R-pakken [{`osmdata`}](https://cran.r-project.org/web/packages/osmdata/vignettes/osmdata.html) til at hente OSM-data direkte i `R`

* Her skal vi bruge
  + En geografisk afgrænsning
  + Valg af features (vha. argumenterne `key` og `value`):

\column{.4\textwidth}


\begin{figure}[H]
	\centering
	\includegraphics[width=.90\textwidth]{pictures/sundell_bars.png}
\end{figure}


\columnsend








## OpenStreetMap: et eksempel

\columnsbegin
\column{.5\textwidth}

```{r, eval=F, warning=FALSE}
library(osmdata)

# Hent OSM-data for Vejle
vejle <- kommuner_raw %>% 
  filter(navn == "Vejle")

vejle_bbox <- vejle %>% 
  st_bbox()

osm <- vejle_bbox %>% 
  opq()

# Hent udvalgte veje
roads <- osm %>% 
  add_osm_feature(key = 'highway',
                  value = c('motorway', 'trunk',
                            'primary', 'secondary', 
                            'tertiary')) %>% 
  osmdata_sf()

# Beskær
roads <- roads$osm_lines %>% 
  st_intersection(., vejle)

# Plot vejene
ggplot() +
  geom_sf(data = vejle, fill = "white") +
  geom_sf(data = roads, aes(color = as.numeric(maxspeed))) +
  scale_color_viridis_c(direction = -1, name = "Speed limit (km/h)") +
  epitheme_map()

```
\column{.5\textwidth}
```{r, echo=F, warning=FALSE}
library(osmdata)

# Hent OSM-data for Vejle
vejle <- kommuner_raw %>% 
  filter(navn == "Vejle")

vejle_bbox <- vejle %>% 
  st_bbox()

osm <- vejle_bbox %>% 
  opq()

# Hent udvalgte veje
roads <- osm %>% 
  add_osm_feature(key = 'highway',
                  value = c('motorway', 'trunk',
                            'primary', 'secondary', 
                            'tertiary')) %>% 
  osmdata_sf()

# Beskær
roads <- roads$osm_lines %>% 
  st_intersection(., vejle)

# Plot vejene
ggplot() +
  geom_sf(data = vejle, fill = "white") +
  geom_sf(data = roads, aes(color = as.numeric(maxspeed))) +
  scale_color_viridis_c(direction = -1, name = "Speed limit (km/h)") +
  epitheme_map()

```
\columnsend


# Værktøjer i `R`

## text

xx
